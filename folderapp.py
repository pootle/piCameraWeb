#!/usr/bin/python3
"""
simple module to manage the video files generated by the camera app
"""
import papp
from pootlestuff import pvars
import os, pathlib, time

vardefs=(
    {'name': 'basefold',    '_cclass': pvars.folderVar,     'fallbackValue': '~/camfiles/videos', 'filters': ['pers']},
    {'name': 'ffilter',     '_cclass': pvars.textVar,       'fallbackValue': '.mpg'},
    {'name': 'filecount',   '_cclass': pvars.intVar,        'fallbackValue': 0},
    {'name': 'countin',     '_cclass': pvars.enumVar,       'fallbackValue': 'today', 'vlist': ['today','yesterday','this month', 'all']},
)

class fileManager(papp.appManager):
    def __init__(self, basefolder, **kwargs):
        self.basefoldervar=basefolder
        super().__init__(name='fileman', **kwargs)
        print('folder using base', self.basefoldervar.getValue())
        self.currentfiles=None
        self.filetime=time.time()

    def make_page(self, apps, pup, qp):
        if self.currentfiles is None or self.filetime+15 < time.time():
            self.currentfiles=filething(root=self.basefoldervar.getValue())
            self.filetime=time.time()
        c=self.currentfiles.make_html()
        return page.format(stuff=c)

    def vidpage(self, apps, pup, qp):
        return vpage.format(qp['fileid'][0])

    def resolvevidfile(self, qp):
        fp=self.basefoldervar.getValue()/qp['fileid'][0]
        return fp

vpage="""<html><body>
<video src="vs.mp4?fileid={}" controls>
</video>
</body></html>
"""

page="""<html><head>\n
<link rel="stylesheet" href="stat/filebits.css">
<script src="stat/filebits.js"></script>
<script type="text/javascript">
    window.onload=startup

    function startup() {{
        settree();
    }}
</script>
</head>
<body>
<div>
    <h3><a href="index.html">camera</a></h3>
    <form>
    {stuff}
    </form>
</div>
<div id="vidhere">
<span>nothing yet</span>
</div>
</body>
</html>
"""

def sizestr(size):
    if size < 10000:
        return '{:,}B '.format(size)
    if size < 10000000:
        return '{:,}KB'.format((size+499)//1000)
    if size < 10000000000:
        return '{:,}MB'.format((size+499999)//1000000)
    return '{:,}GB'.format((size+499999999)//1000000000)

filestr='%s%-25s (%7s)'

class filething():
    def __init__(self, root, sorton='name', filtercount=None, showerrors=True):
        assert sorton in ('name', 'size')
        rp=pathlib.Path(root).expanduser().resolve()
        basedepth=len(str(rp).split('/'))
        xgen=os.fwalk(str(rp),)
        xgc=0
        print('in', rp)
        for dirpath, dirnames, filenames, dir_fd in xgen:
            pathsplit=dirpath.split('/')
            try:
                finfos=[(fn, os.stat(fn, dir_fd=dir_fd).st_size) for fn in filenames]
            except:
                finfos=[]
                for fn in filenames:
                    try:
                        finfos.append((fn, os.stat(fx, dir_fd=dir_fd).st_size))
                    except:
                        if showerrors:
                            print('oops at', fn, 'in', dirpath)
            filtcount=0
            if not filtercount is None:
                for fn in filenames:
                    if fn.endswith(filtercount):
                        filtcount+=1
            if sorton=='name':
                sortix=0
                sreverse=False
            elif sorton=='size':
                sortix=1
                sreverse=True
            else:
                raise ValueError('I cannot sort on' + str(sorton))
            finfos.sort(key=lambda x: x[sortix], reverse=sreverse)
            dirdict={'folds': {},
                     'files': dict(finfos),
                     'path' : dirpath,
                     'name' : pathsplit[-1]}
            pcount=len(pathsplit)-basedepth
            if pcount==0:
                self.data=dirdict
                plist=[dirdict]
            elif pcount==len(plist):
                plist[-1]['folds'][pathsplit[-1]] = dirdict
                plist.append(dirdict)
            elif pcount > len(plist):
                print('NEVERRRRRRRRRRR')
            elif pcount < len(plist):
                while pcount < len(plist):
                    finished = plist.pop(-1)
                    finished['size'] = sum(finished['files'].values()) + sum(f['size'] for f in finished['folds'].values())
                    finished['filtc'] = len(finished['files']) + sum(f['filtc'] for f in finished['folds'].values())
                    if len(finished['folds']) > 0:
                        sx=list(finished['folds'].items())
                        sx.sort(key=lambda kv: kv[1][sorton], reverse=sreverse)
                        finished['folds']=dict(sx)
                plist[-1]['folds'][pathsplit[-1]] = dirdict  
                plist.append(dirdict)
            else:
                print('too steep?')
            xgc +=1
        while len(plist) > 0:
            finished=plist.pop(-1)
            finished['size'] = sum(finished['files'].values()) + sum(f['size'] for f in finished['folds'].values())
            if len(finished['folds']) > 0:
                sx=list(finished['folds'].items())
                sx.sort(key=lambda kv: kv[1][sorton], reverse=sreverse)
                finished['folds']=dict(sx)
        print(sizestr(self.data['size']))

    def pretty(self, levels=2):
        prettydict(self.data, levels=levels, indent=0)

    def make_html(self):
        return '<p>no files found</p>' if len(self.data['files'])==0 and len(self.data['folds']) == 0 else '<ul class="ftree">\n'+htmldict(self.data, indent=1)+'</ul>\n'

lifilehtml='{ind:s}<li><span>{name:s}</span><span>{size:s}</span><input type="checkbox" name="x" value=""></li>\n'
#lilifihtml='{ind:s}<li><span><a href="vs.html?fileid={upstr}/{dn}/{name}">{name:s}</a></span><span>{size:s}</span><input type="checkbox" name="{upstr}/{dn}/{name}" value=""></li>\n'
lilifihtml="""{ind:s}<li><span onclick="showvid('{upstr}/{dn}/{name}')" >{name:s}</span><span>{size:s}</span><input type="checkbox" name="{upstr}/{dn}/{name}" value=""></li>\n"""
lifoldhtml='{ind:s}<li><a href="#"><span>{name:s}</span></a>{size:s}\n{ind:s}<ul class="ftree">\n{fstr:s}{ind:s}</ul></li>\n'

def htmldict(adict, indent, upstr=''):
    istr='  ' * indent
    files=[(lilifihtml if fn.endswith('.mp4') else lifilehtml).format(ind=istr, name=fn, dn=adict['name'], size=sizestr(fs), upstr=upstr) for fn, fs in adict['files'].items()]
    upstr='' if indent==1 else adict['name'] if indent==2 else upstr+'/'+adict['name'] 
    folds=[lifoldhtml.format(
            ind=istr, name=fdict['name'], size=sizestr(fdict['size']), fstr=htmldict(fdict, indent+1, upstr))
               for fdict in adict['folds'].values()]
    return ''.join(folds)+''.join(files)

def prettydict(adict, levels, indent):
    prestr='|   ' * indent
    print('{:s}{:22s} {:s}'.format(prestr, adict['name'], sizestr(adict['size'])))
    if levels > 0:
        prestr += '|   '
        for fn, fs in adict['files'].items():
            print('{:s}{:22s} {:s}'.format(prestr, fn, sizestr(fs)))
        for dn in adict['folds'].values():
            prettydict(dn, levels-1, indent+1)
