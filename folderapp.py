#!/usr/bin/python3
"""
simple module to manage the video files generated by the camera app
"""
from pootlestuff import watchables as wv
import os, pathlib, time, threading, queue

class fileManager(wv.watchablesmart):
    def __init__(self, **kwargs):
        self.diskfree=wv.floatWatch(app=self, value=float('nan'))
        wables=[
            ('basefoldervar',     wv.folderWatch,       '',  False),
        ]
        super().__init__(wabledefs=wables, **kwargs)
        self.currentfiles=None
        self.filetime=time.time()
        self.cq=queue.Queue()
        self.running=True
        self.fthread=threading.Thread(name='filer', target=self.slowthread)
        self.fthread.start()

    def make_page(self, pagelist, qp, pp, page):
        if self.currentfiles is None or 'refresh' in qp:
            self.currentfiles=filething(root=self.basefoldervar.getValue())
            self.filetime=time.time()
        with open(page, 'r') as pf:
            return {'resp':200, 'headers': (('Content-Type', 'text/html; charset=utf-8'),), 'data': pf.read().format(stuff=self.currentfiles.make_html())}

    def vidpage(self, pagelist, qp, pp):
        return vpage.format(qp['fileid'][0])

    def resolvevidfile(self, qp):
        fp=self.basefoldervar.getFolder()/qp['fileid'][0]
        return fp

    def slowthread(self):
        cmd=None
        while self.running:
            if cmd is None:
                fp=self.basefoldervar.getValue()
                diskinfo=os.statvfs(fp)
                nv=diskinfo.f_bavail/diskinfo.f_blocks
                self.diskfree.setValue(nv,wv.myagents.app)
            try:
                cmd=self.cq.get(timeout=10)
            except queue.Empty:
                cmd=None

    def stopme(self):
        self.running=False
        self.cq.put('stop')
        self.fthread.join()

def sizestr(size):
    if size < 10000:
        return '{:,}B '.format(size)
    if size < 10000000:
        return '{:,}KB'.format((size+499)//1000)
    if size < 10000000000:
        return '{:,}MB'.format((size+499999)//1000000)
    return '{:,}GB'.format((size+499999999)//1000000000)

filestr='%s%-25s (%7s)'

class filething():
    def __init__(self, root, sorton='name', filtercount=None, showerrors=True):
        assert sorton in ('name', 'size')
        rp=pathlib.Path(root).expanduser().resolve()
        basedepth=len(str(rp).split('/'))
        xgen=os.fwalk(str(rp),)
        xgc=0
        print('in', rp)
        for dirpath, dirnames, filenames, dir_fd in xgen:
            pathsplit=dirpath.split('/')
            try:
                finfos=[(fn, os.stat(fn, dir_fd=dir_fd).st_size) for fn in filenames]
            except:
                finfos=[]
                for fn in filenames:
                    try:
                        finfos.append((fn, os.stat(fx, dir_fd=dir_fd).st_size))
                    except:
                        if showerrors:
                            print('oops at', fn, 'in', dirpath)
            filtcount=0
            if not filtercount is None:
                for fn in filenames:
                    if fn.endswith(filtercount):
                        filtcount+=1
            if sorton=='name':
                sortix=0
                sreverse=False
            elif sorton=='size':
                sortix=1
                sreverse=True
            else:
                raise ValueError('I cannot sort on' + str(sorton))
            finfos.sort(key=lambda x: x[sortix], reverse=sreverse)
            dirdict={'folds': {},
                     'files': dict(finfos),
                     'path' : dirpath,
                     'name' : pathsplit[-1]}
            pcount=len(pathsplit)-basedepth
            if pcount==0:
                self.data=dirdict
                plist=[dirdict]
            elif pcount==len(plist):
                plist[-1]['folds'][pathsplit[-1]] = dirdict
                plist.append(dirdict)
            elif pcount > len(plist):
                print('NEVERRRRRRRRRRR')
            elif pcount < len(plist):
                while pcount < len(plist):
                    finished = plist.pop(-1)
                    finished['size'] = sum(finished['files'].values()) + sum(f['size'] for f in finished['folds'].values())
                    finished['filtc'] = len(finished['files']) + sum(f['filtc'] for f in finished['folds'].values())
                    if len(finished['folds']) > 0:
                        sx=list(finished['folds'].items())
                        sx.sort(key=lambda kv: kv[1][sorton], reverse=sreverse)
                        finished['folds']=dict(sx)
                plist[-1]['folds'][pathsplit[-1]] = dirdict  
                plist.append(dirdict)
            else:
                print('too steep?')
            xgc +=1
        while len(plist) > 0:
            finished=plist.pop(-1)
            finished['size'] = sum(finished['files'].values()) + sum(f['size'] for f in finished['folds'].values())
            if len(finished['folds']) > 0:
                sx=list(finished['folds'].items())
                sx.sort(key=lambda kv: kv[1][sorton], reverse=sreverse)
                finished['folds']=dict(sx)
        print(sizestr(self.data['size']))

    def pretty(self, levels=2):
        prettydict(self.data, levels=levels, indent=0)

    def make_html(self):
        return '<p>no files found</p>' if len(self.data['files'])==0 and len(self.data['folds']) == 0 else '<ul class="ftree">\n'+htmldict(self.data, indent=1)+'</ul>\n'

lifilehtml='{ind:s}<li><span>{name:s}</span><span>{size:s}</span><input type="checkbox" name="x" value=""></li>\n'
lilifihtml="""{ind:s}<li><span onclick="showvid('{upstr}/{dn}/{name}')" style="cursor: pointer;" >{name:s}</span><span>{size:s}</span><input type="checkbox" name="{upstr}/{dn}/{name}" value=""></li>\n"""
lifoldhtml='{ind:s}<li{preop}><a href="#"><span>{name:s}</span></a>{size:s}\n{ind:s}<ul class="ftree">\n{fstr:s}{ind:s}</ul></li>\n'

def htmldict(adict, indent, upstr=''):
    istr='  ' * indent
    files=[(lilifihtml if fn.endswith('.mp4') else lifilehtml).format(ind=istr, name=fn, dn=adict['name'], size=sizestr(fs), upstr=upstr) for fn, fs in adict['files'].items()]
    upstr='' if indent==1 else adict['name'] if indent==2 else upstr+'/'+adict['name']
    flist=list(adict['folds'].values())
    if flist:
        folds=[lifoldhtml.format(
            ind=istr, name=fdict['name'], size=sizestr(fdict['size']), fstr=htmldict(fdict, indent+1, upstr), preop='')
               for fdict in flist[:-1]]
        fdict=flist[-1]
        folds.append(lifoldhtml.format(
            ind=istr, name=fdict['name'], size=sizestr(fdict['size']), fstr=htmldict(fdict, indent+1, upstr), preop=' class="open" '))
    else:
        folds=[]
    return ''.join(folds)+''.join(files)

def prettydict(adict, levels, indent):
    prestr='|   ' * indent
    print('{:s}{:22s} {:s}'.format(prestr, adict['name'], sizestr(adict['size'])))
    if levels > 0:
        prestr += '|   '
        for fn, fs in adict['files'].items():
            print('{:s}{:22s} {:s}'.format(prestr, fn, sizestr(fs)))
        for dn in adict['folds'].values():
            prettydict(dn, levels-1, indent+1)
